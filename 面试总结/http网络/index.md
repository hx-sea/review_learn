## 网络和并发

### HTTP/1.0/1.1/2.0 在并发请求上的主要区别是什么？

1. HTTP/1.0

- 每个 TCP 连接只能发送一个请求，当服务器响应后就会关闭这个连接，下一次请求需要再次建立 TCP 连接

2. HTTP/1.1

- 默认采用持久连接 在请求头加 Connection:keep-alive close 为关闭连接

* 管道机制：在同一个 TCP 连接里允许多个请求同时发送
* 但是所有的数据通信是有顺序的，A，B，C，如果 A 请求响应时间太长，会造成对头阻塞

3.  HTTP/2.0

    1.2. 多路复用：同一个连接同时处理多个请求，没有次序概念

    1.3. 加了服务器推送功能

    1.4. 头部压缩

    - 针对头部字段，采用了对应的压缩算法：HPACK，对请求头进行压缩
    - 在服务端和客户端建立哈希表，保存用到的字段，传输过程中对于重复出现的字段，只要把索引传给对方即可，对方拿到索引查表就行了，让请求头字段得到了极大的精简和复用

### HTTP/1.1 的长连接和 HTTP/2.0 的多路复用有什么区别

- 1.1：同一时间一个 TCP 只能处理一个请求，采用请求-响应的形式

* chrome 支持最大 6 个 TCP 连接

* 2.0: 同域名的所有通信都在单个连接上完成，单个连接可以并行交错的进行响应和请求

### 为什么 HTTP/1.1 不能实现多路复用

- HTTP/2.0 是基于二进制帧的协议，HTTP/1.1 是基于文本分割解析的协议

- 1.1 的报文结构里，服务器需要不断的读入字节

- 2.0 是以帧为最小单位数据，每个帧都会有标识自己属于那个流，每个帧组成一个流， 多路复用，其实就是一个 TCP 里存在多条流

### http 缓存

<a href = 'http://47.98.159.95/my_blog/blogs/perform/001.html#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98'></a>

1. 强缓存

- 这个阶段不需要发送 http 请求，直接从缓存获取数据

  1.  Expires： 过期时间，

      - 比如 Expires: Wed, 22 Nov 2019 08:41:00 GMT，表示资源在 2019 年 11 月 22 号 8 点 41 分过期，过期了就得向服务端发请求。
      - 坑： 服务器的时间和浏览器的时间可能不一致

  2.  Cache-Control： 过期时长

      - Cache-Control:max-age=3600，代表这个响应在 3600 秒之后，也就是一个小时之类可以直接使用缓存
      - 其他值：
        1. no-cache: 跳过当前的强缓存，发送 http 请求，即直接进入协商缓存阶段.
        2. no-store: 非常粗暴， 不使用任何形式缓存

2. 协商缓存

- 强缓存失效后，浏览器在请求头携带相应的缓存 Tag 来向服务器发送请求，由服务器根据这个 Tag 来决定是否使用缓存

* 两个 Tag

1. Last-Modified

   - 浏览器第一次请求 -> 服务器在响应头加上这个字段 -> 浏览器再次请求携带 If-Modefied-Since(就是服务器传来的最后修改时间) -> 服务器拿到 If-Modefied-Since 和该资源的最后修改时间对比 -> 如果小于最后修改时间，说明是时候更新了否则 304，直接使用缓存

2. Etag
   - 服务器根据当前文件内容，给文件生成唯一标识，只要里面的内容有改动，这个值就会变，服务器通过响应头把这个值给浏览器 -> 浏览器接收到 Etag，在下次请求时，将这个值作为 If-None-Match 的内容，放到请求头中，发给服务器 -> 服务器接收到 If-None-Match 之后进行对比

二进制分帧首先 http2.0 认为明文传输太麻烦， 不好解析， 所以干脆把报文全部转成二进制格式，全部传输 01 串，方便机器的解析

- 原来的 headers+body 的报文格式被拆分成了一个个二进制帧，Headers 存放头部字段，datas 存放请求体字段，基于帧传输之后 服务器看的不再是完整的 http 请求报文，而是一堆乱序的二进制帧，这些二进制帧不存在先后关系，因此就不会排队等待，也就没有了 http 队头阻塞问题

- 通信双方都可以给对方发送二进制帧，这种二进制帧的双向传输序列 就是流 http2.0 用流来在一个 TCP 连接上来进行多个数据帧的通信，这就是多路复用的概念

* websocket 是基于 http1.1 的协议传输 在 js 中通过 new Websocket

* 而 http2.0 是对 html css js 资源的传输进行了优化，并没有提供新的 js api

* TCP 3 次握手原因：为了解决网络中存在延迟的重复分组问题，防止已失效的链接请求报文从传送到服务端，因而产生错误，防止服务端浪费资源
* 四次挥手原因：客户端断开时服务端还有未发送的数据，因此将服务端的 ACK 和数据传输分成两次发送，因此比建立多了一次

## 闭包

1. mdn 中的解释是： 闭包就是能够访问自由变量的函数， 自由变量是指既不是函数内部定义的变量 也不是函数的参数

2. 即使函数的上下文被销毁了， 仍然存在 ，在代码中引用了自由变量

## 作用域

1. 作用域指的是程序代码中定义变量的区域
2. 作用域规定了如何查找变量，也就是规定了执行代码对当前变量的访问权限
3. js 采用词法作用域，就是静态作用域，即函数创建的时候决定作用域

### 执行上下文

1. 可执行代码分为全局代码、 函数代码、 eval 代码
2. 执行上下文栈，压入执行上下文栈，执行完毕，从执行上下文栈退出

### 作用域链

1. 当查找变量的时候，会先从当前上下文变量对象中查找，找不到，再从父级执行上下文查找，直到找到全局上下文的变量对象
